## Misc 

Design Considerations: 
- Coupling 
- Chattiness 
- Client complexity 
- Cognitive complexity 
- Caching 
- Discoverability 
- Versioning 

#### RPC 
- Remote procedure call 
- Origin in 80s or 70s 
- "Call a function on another server" 
- Fundamental unit: function 
- Fits well with action or command-oriented systems 
- Easy to add new endpoints by simply adding new functions 
(both good and bad)
- Advantages 
    - Simple, easy to understand (clients can often be generated by 
    set of functions)
    - Lightweight payloads, low overhead 
    - High performance 
- Disadvantages 
    - Tight coupling to underlying system, low abstraction (easy to 
    leak details into API)
    - No discoverability (hard to learn quickly) 
    - Function explosion - easy to build an overabundance of overly 
    granular, overlapping functions as needs arise 

#### REST 
- Representational State Transfer 
- Origin in 90s via Roy T. Fielding 
- Decouples client from server as much as possible 
- "Here are some resources and what you can do with them" 
- Fundamental unit: resource 
- Shouldn't require external documentation for use 
- Including application state info in hypertext allows full decoupling 
of client and server, and by extension independent development 
- Ages better than RPC - new features can be built w/ the same resources, 
instead of writing new endpoint functions 
- Advantages 
    - Decoupled client and server
    - API can evolve over time 
    - Reuses HTTP 
- Disadvantages 
    - No single spec for building REST (e.g. HAL, JSON-API, Ion)
    - Large payloads (loaded down w/ metadata), chattiness (requires many
    requests)
        - Poor performance w/ limited bandwidth and pipeline (e.g. phone 
        w/ bad reception, short latency)

#### GraphQL
- "Ask for exactly what you want" 
- Fundamental unit: query 
- Built upon a strongly typed schema  
- Advantages 
    - Low network overhead 
    - Typed schema (provides discoverability)
    - Fits graph-like data well (e.g. linked relations; flat data doesn't take full advantage) 
- Disadvantages 
    - Complexity (but powerful)
    - Caching tricky b/c HTTP caching semantics not used 
        - POST verb most often used by GraphQL, but doesn't support caching by HTTP definition 
        - Custom caching required 
        - React / Redux can handle caching 
    - Versioning - API not versioned, but updated queries should still work

|                | Coupling | Chattiness | Client complexity | Cognitive complexity | Caching | Discoverability | Versioning | 
|----------------|:--------:|:----------:|:-----------------:|:--------------------:|:-------:|:---------------:|:----------:|
| RPC Functions  | High     | Medium     | Low               | Low                  | Custom  | Bad             | Hard       |
| REST Resources | Low      | High       | Low               | Low                  | HTTP    | Good            | Easy       |
| GraphQL Queries| Medium   | Low        | High              | High                 | Custom  | Good            | ???        |

#### Engineering decisions: 
- Ask, "Who uses my API?" 
- Use cases: 
    - Management API 
        - Focus on objects or resources 
        - Many varied clients 
        - Discoverability and documentation 
        - **Consider**: REST (Ion, HAL, JSON-API)
        - Ex: Twilio, Stripe, Stack Exchange, Okta 
    - Action-oriented 
        - Simple interactions 
        - **Consider**: RPC  
        - Ex: Slack 
    - Internal microservices 
        - High message rate 
        - High message / network performance 
        - Minimize metadata transmitted, low overhead 
        - **Consider**: RPC (gRPC using HTTP2 to optimize network layer, Twerp) or REST 
    - Data or Mobile API 
        - Graph-like data 
        - Optimize for high latency 
        - **Consider**: GraphQL 
- Consider using small use cases to evaluate which API design works best for your application 

#### Sources: 
- [API Throwdown: RPC vs REST vs GraphQL - Nate Barbettini](https://www.youtube.com/watch?v=IvsANO0qZEg)

#### Sources to check out: 
- Les Hazlewood on REST API design 
- Eric Baer on GraphQL
- Twilio, Stripe, Paypal documentation 
- Sphinx for writing more powerful API docs 